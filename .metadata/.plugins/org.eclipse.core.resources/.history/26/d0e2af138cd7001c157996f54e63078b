/*
 * gpio.c
 *
 *  Created on: May 19, 2022
 *      Author: danim
 */

#include "gpio.h"
/*********GPIO clock control***************/
void GPIO_ClockControl(GPIO_RegStruct_t *pGPIO, uint8_t EnableDisable){

	if (EnableDisable == ENABLE) {
		switch (pGPIO) {
			case GPIOA:
				GPIOA_EnableClock();
				break;
			case GPIOA:
				GPIOA_EnableClock();
				break;
			case GPIOB:
				GPIOB_EnableClock();
				break;
			case GPIOC:
				GPIOC_EnableClock();
				break;
			case GPIOD:
				GPIOD_EnableClock();
				break;
			case GPIOE:
				GPIOE_EnableClock();
				break;
			case GPIOF:
				GPIOF_EnableClock();
				break;
			default:
				break;
		}
	}
	else{
		switch (pGPIO) {
			case GPIOA:
				GPIOA_DisableClock();
				break;
			case GPIOA:
				GPIOA_DisableClock();
				break;
			case GPIOB:
				GPIOB_DisableClock();
				break;
			case GPIOC:
				GPIOC_DisableClock();
				break;
			case GPIOD:
				GPIOD_DisableClock();
				break;
			case GPIOE:
				GPIOE_DisableClock();
				break;
			case GPIOF:
				GPIOF_DisableClock();
				break;
			default:
				break;
		}
	}
}
/*********GPIO pin initialization*************/
void GPIO_PinInit(GPIO_PinHandle_t *GPIO_PinHandle){

	//enable GPIO port clock
	GPIO_ClockControl(GPIO_PinHandle->pGPIO,ENABLE);

	//configure MODE: if not interrupt, mode is input/output/analog/alternate function
	if ((GPIO_PinHandle->GPIO_PinConfig.GPIO_PinMode)<=GPIO_ANA){
		// first,reset the 2 bits related to pin.ex:pin number 1 is for MODER bits 2 and 3.3<<2*pin is 3<<2 aka 1100b.so MODER&=(~1100)=x..x00xx
		GPIO_PinHandle->pGPIO->MODER &= (~(0x3<<(2*GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber))); //I guess I could've used 3 instead of 0x3
		//now set
		GPIO_PinHandle->pGPIO->MODER |= (GPIO_PinHandle->GPIO_PinConfig.GPIO_PinMode<<(2*GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));
	}
	else{ //interrupts
		//TBD
	}

	//OUTPUT TYPE. TBD:don't do if !=output mode?
	// first,reset the related bit
	GPIO_PinHandle->pGPIO->OTYPER &= (~(0x1<<GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));
	//now set
	GPIO_PinHandle->pGPIO->OTYPER |= (GPIO_PinHandle->GPIO_PinConfig.GPIO_PinOutType<<(GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));

	//OUTPUT SPEED. TBD:don't do if !=output mode?
	// first,reset the related bits
	GPIO_PinHandle->pGPIO->OSPEEDR &= (~(0x3<<GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));
	//now set
	GPIO_PinHandle->pGPIO->OSPEEDR |= (GPIO_PinHandle->GPIO_PinConfig.GPIO_PinOutSpeed<<(2*GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));

	//PULL UP/DOWN
	// first,reset the related bits
	GPIO_PinHandle->pGPIO->PUPDR &= (~(0x3<<GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));
	//now set
	GPIO_PinHandle->pGPIO->PUPDR |= (GPIO_PinHandle->GPIO_PinConfig.GPIO_PinPullUpDown<<(GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber));

	//ALTERNATE FUNCTION
	if (GPIO_PinHandle->GPIO_PinConfig.GPIO_PinMode==GPIO_ALTFUN){
		//as there are 2 registers, low is for pins 0-7 and high for 8-15.in our struct,AFR[2].We need to know where to actuate
		uint8_t regAltFun = GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber / 8 ; //ex: pin 7-->reg 0,byte=7(last);pin12 --> reg1, byte=4
		uint8_t byteAltFun = GPIO_PinHandle->GPIO_PinConfig.GPIO_PinNumber % 8;
		// first,reset the related bits. in this case, 4. ~1111 is ~0x0F
		GPIO_PinHandle->pGPIO->AFR[regAltFun] &= (~(0xF<<byteAltFun));
		//now set
		GPIO_PinHandle->pGPIO->AFR[regAltFun] |= (GPIO_PinHandle->GPIO_PinConfig.GPIO_PinAlterFunc<<(4*byteAltFun));
	}
}
/*********GPIO port reset**********************/
void GPIO_ResetPort(GPIO_RegStruct_t *pGPIO){
	switch (pGPIO) {
		case GPIOA:
			GPIOA_Reset();
			break;
		case GPIOA:
			GPIOB_Reset();
			break;
		case GPIOB:
			GPIOC_Reset();
			break;
		case GPIOC:
			GPIOC_Reset();
			break;
		case GPIOD:
			GPIOD_Reset();
			break;
		case GPIOE:
			GPIOE_Reset();
			break;
		case GPIOF:
			GPIOF_Reset();
			break;
		default:
			break;
	}
}
